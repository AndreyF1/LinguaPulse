// payment-worker.js
// Handles subscription payment and updates user profile
// Now includes Tribute.tg integration alongside existing functionality

export default {
  async fetch(request, env) {
    // Only accept POST requests
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }
    
    // Parse the request body
    let data;
    try {
      data = await request.json();
    } catch (error) {
      return new Response('Invalid JSON', { status: 400 });
    }
    
    // Get action type from request
    const action = data.action;
    
    // Route to appropriate handler based on action
    if (action === 'process_subscription') {
      // Original Stripe handler
      const telegramId = data.telegram_id;
      if (!telegramId || isNaN(parseInt(telegramId))) {
        return new Response('Invalid telegram ID', { status: 400 });
      }
      return await processStripeSubscription(telegramId, env);
    } 
    else if (action === 'start_tribute_subscription') {
      // New method to redirect user to Tribute channel subscription
      const telegramId = data.telegram_id;
      if (!telegramId || isNaN(parseInt(telegramId))) {
        return new Response('Invalid telegram ID', { status: 400 });
      }
      return await startTributeSubscription(telegramId, env);
    } 
    else if (action === 'process_tribute_webhook') {
      // Process Tribute webhook data forwarded from telegram-webhook
      return await processTributeWebhook(data, env);
    } 
    else {
      return new Response('Invalid action', { status: 400 });
    }
  }
};

// Original Stripe subscription handler - kept unchanged to preserve existing functionality
async function processStripeSubscription(telegramId, env) {
  // Get the current user profile
  const { results } = await env.USER_DB
    .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
    .bind(parseInt(telegramId, 10))
    .all();
  
  if (!results.length) {
    return new Response('User not found', { status: 404 });
  }
  
  const profile = results[0];
  
  // Calculate subscription dates
  const now = new Date();
  const subscribed_at = now.toISOString();
  
  // Set expiration date to 7 days from now (end of that day)
  const expirationDate = new Date(now);
  expirationDate.setDate(expirationDate.getDate() + 7);
  expirationDate.setHours(23, 59, 59, 999);
  const subscription_expired_at = expirationDate.toISOString();
  
  // For new subscriptions, make the lesson immediately available
  const nextLessonDate = new Date(now);
  // Check if this is the user's first subscription
  if (!profile.subscription_expired_at || new Date(profile.subscription_expired_at) < now) {
    // First time subscriber or subscription was expired - make lesson available immediately
    nextLessonDate.setTime(now.getTime() - 60000); // Set to 1 minute ago to ensure it's available
  } else {
    // Renewal - follow the normal schedule
    nextLessonDate.setHours(2, 0, 0, 0);
    // If it's already past 2 AM, set to tomorrow
    if (now.getHours() >= 2) {
      nextLessonDate.setDate(nextLessonDate.getDate() + 1);
    }
  }
  
  const next_lesson_access_at = nextLessonDate.toISOString();
  
  // Calculate new amount paid (add $1 to current value)
  const currentAmount = profile.amount_paid || 0;
  const amount_paid = currentAmount + 1;
  
  try {
    // Update the user profile in the database
    await env.USER_DB
      .prepare(`
        UPDATE user_profiles 
        SET subscribed_at = ?, 
            subscription_expired_at = ?, 
            next_lesson_access_at = ?, 
            amount_paid = ?
        WHERE telegram_id = ?
      `)
      .bind(
        subscribed_at,
        subscription_expired_at,
        next_lesson_access_at,
        amount_paid,
        parseInt(telegramId, 10)
      )
      .run();
    
    // Send confirmation message to the user
    await sendSubscriptionConfirmation(telegramId, env);
    
    return new Response(JSON.stringify({
      success: true,
      message: "Subscription activated successfully",
      subscription_expired_at: subscription_expired_at,
      next_lesson_access_at: next_lesson_access_at
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('Error processing subscription:', error);
    return new Response(JSON.stringify({
      success: false,
      error: "Database error"
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// New method to start the Tribute subscription process
async function startTributeSubscription(telegramId, env) {
  try {
    // Store user's information in KV to associate with webhook later
    await env.CHAT_KV.put(`tribute_pending:${telegramId}`, JSON.stringify({
      status: 'pending',
      created_at: new Date().toISOString()
    }), {
      expirationTtl: 86400 // Store for 24 hours
    });
    
    // Get the channel link from environment variable
    const channelLink = env.TRIBUTE_CHANNEL_LINK || 'https://t.me/LinguaPulseChannel';
    
    // Send message with direct channel link to the user
    await sendTributeChannelLink(telegramId, channelLink, env);
    
    return new Response(JSON.stringify({
      success: true,
      message: "Tribute subscription initiated",
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('Error starting Tribute subscription:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Unknown error"
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Process webhook from Tribute
async function processTributeWebhook(data, env) {
  try {
    console.log('Received Tribute webhook:', JSON.stringify(data));
    
    // Verify webhook signature if provided
    if (data.signature && !verifyTributeSignature(data, env.TRIBUTE_API_KEY)) {
      return new Response('Invalid signature', { status: 403 });
    }
    
    // Check if this is a new subscription event
    if (data.name !== 'new_subscription') {
      console.log(`Ignoring non-subscription webhook event: ${data.name}`);
      return new Response('OK', { status: 200 });
    }
    
    // Extract payload
    const payload = data.payload;
    if (!payload) {
      return new Response('Missing payload', { status: 400 });
    }
    
    // Get Telegram user ID from webhook
    const telegramUserId = payload.user_id;
    if (!telegramUserId) {
      return new Response('Missing user ID', { status: 400 });
    }
    
    // Verify the subscription is for our channel
    const channelId = payload.channel_id;
    const expectedChannelId = parseInt(env.TRIBUTE_CHANNEL_ID, 10);
    
    if (channelId !== expectedChannelId) {
      console.log(`Webhook for different channel (${channelId}), expected ${expectedChannelId}`);
      return new Response('Invalid channel', { status: 400 });
    }
    
    console.log(`Processing subscription for user: ${telegramUserId}, channel: ${channelId}`);
    
    // Check if there is a pending subscription for this user
    const pendingKey = `tribute_pending:${telegramUserId}`;
    const pendingData = await env.CHAT_KV.get(pendingKey);
    
    // Even if there's no pending record, we'll still process the subscription
    // This handles cases where users might subscribe directly from the channel
    
    // Get the user profile
    const { results } = await env.USER_DB
      .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
      .bind(parseInt(telegramUserId, 10))
      .all();
    
    if (!results.length) {
      console.log(`User ${telegramUserId} not found in database, creating new profile`);
      // Create a new user profile if one doesn't exist
      await env.USER_DB
        .prepare(`
          INSERT INTO user_profiles (telegram_id) 
          VALUES (?)
        `)
        .bind(parseInt(telegramUserId, 10))
        .run();
    }
    
    const now = new Date();
    const subscribed_at = now.toISOString();
    
    // Set expiration based on webhook data or default to 30 days
    let expirationDate;
    if (payload.expires_at) {
      expirationDate = new Date(payload.expires_at);
    } else {
      expirationDate = new Date(now);
      expirationDate.setDate(expirationDate.getDate() + 30); // Default to 30 days
      expirationDate.setHours(23, 59, 59, 999);
    }
    
    const subscription_expired_at = expirationDate.toISOString();
    
    // Make the lesson immediately available
    const nextLessonDate = new Date(now);
    nextLessonDate.setTime(now.getTime() - 60000); // Set to 1 minute ago to ensure it's available
    const next_lesson_access_at = nextLessonDate.toISOString();
    
    // Calculate payment amount
    let paymentAmount = 0;
    if (payload.amount) {
      paymentAmount = payload.amount / 100; // Convert cents to dollars/euros
    } else if (payload.price) {
      paymentAmount = payload.price / 100;
    }
    
    try {
      // Update the user profile with subscription details
      await env.USER_DB
        .prepare(`
          UPDATE user_profiles 
          SET subscribed_at = ?, 
              subscription_expired_at = ?, 
              next_lesson_access_at = ?, 
              amount_paid = COALESCE(amount_paid, 0) + ?
          WHERE telegram_id = ?
        `)
        .bind(
          subscribed_at,
          subscription_expired_at,
          next_lesson_access_at,
          paymentAmount,
          parseInt(telegramUserId, 10)
        )
        .run();
      
      // Clean up the pending subscription record
      if (pendingData) {
        await env.CHAT_KV.delete(pendingKey);
      }
      
      // Store successful subscription data
      await env.CHAT_KV.put(`tribute_subscription:${telegramUserId}`, JSON.stringify({
        status: 'active',
        started_at: now.toISOString(),
        expires_at: subscription_expired_at,
        subscription_id: payload.subscription_id,
        period: payload.period
      }));
      
      // Send confirmation message to the user
      await sendSubscriptionConfirmation(telegramUserId, env);
      
      return new Response(JSON.stringify({ success: true }), {
        headers: { 'Content-Type': 'application/json' }
      });
      
    } catch (error) {
      console.error('Error updating subscription in database:', error);
      return new Response(JSON.stringify({
        success: false,
        error: "Database error"
      }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  } catch (error) {
    console.error('Error processing Tribute webhook:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Unknown error"
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Verify Tribute webhook signature
// Based on https://wiki.tribute.tg/ru/api-dokumentaciya
function verifyTributeSignature(data, apiKey) {
  // Note: According to current Tribute documentation, they don't provide
  // a specific webhook signature verification method.
  // This function can be updated if they add verification in the future.
  
  // For now, there's no way to verify the webhook sender,
  // so we'll allow all webhooks through. In production, you might
  // want to implement additional security checks if possible.
  
  return true;
}

// Send channel link to user
async function sendTributeChannelLink(chatId, channelLink, env) {
  const message = "To subscribe, join our channel and click the Subscribe button. After successful payment, your subscription will be automatically activated.";
  
  const keyboard = {
    inline_keyboard: [
      [{ text: "Go to channel", url: channelLink }]
    ]
  };
  
  await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text: message,
      reply_markup: keyboard
    })
  });
}

// Send confirmation message via Telegram
async function sendSubscriptionConfirmation(chatId, env) {
  const message = "✅ Your subscription has been activated! You now have access to all lessons for the next period. Would you like to start now?";
  
  const keyboard = {
    inline_keyboard: [
      [{ text: "Start Lesson", callback_data: "lesson:start" }]
    ]
  };
  
  await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text: message,
      reply_markup: keyboard
    })
  });
}
