// payment-worker.js —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Stripe
// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

export default {
  async fetch(request, env) {
    // –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ç–æ–ª—å–∫–æ POST –∑–∞–ø—Ä–æ—Å—ã
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }
    
    // –†–∞–∑–±–∏—Ä–∞–µ–º —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞
    let data;
    try {
      data = await request.json();
    } catch (error) {
      return new Response('Invalid JSON', { status: 400 });
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ç–µ–ª–µ–≥—Ä–∞–º –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
    const telegramId = data.telegram_id;
    if (!telegramId || isNaN(parseInt(telegramId))) {
      return new Response('Invalid telegram ID', { status: 400 });
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
    switch (data.action) {
      case 'create_payment':
        // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é –æ–ø–ª–∞—Ç—ã Stripe
        return await createPaymentSession(telegramId, env);
      
      case 'payment_success':
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—É—é –æ–ø–ª–∞—Ç—É
        return await processSubscription(telegramId, env, data.session_id);
        
      case 'process_subscription':
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã
        return await processSubscription(telegramId, env, data.session_id);
        
      default:
        return new Response('Invalid action', { status: 400 });
    }
  },
};

// –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é –æ–ø–ª–∞—Ç—ã Stripe
async function createPaymentSession(telegramId, env) {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const { results } = await env.USER_DB
      .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
      .bind(parseInt(telegramId, 10))
      .all();
    
    if (!results.length) {
      return new Response('User not found', { status: 404 });
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞
    await env.USER_DB
      .prepare('UPDATE user_profiles SET payment_processing = 1 WHERE telegram_id = ?')
      .bind(parseInt(telegramId, 10))
      .run();
    
    // –°–æ–∑–¥–∞–µ–º Stripe Checkout Session —Å –ø—É—Å—Ç—ã–º–∏ success_url –∏ cancel_url
    const stripeResponse = await fetch('https://api.stripe.com/v1/checkout/sessions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        'payment_method_types[]': 'card',
        'line_items[0][price_data][currency]': 'usd',
        'line_items[0][price_data][product_data][name]': 'Weekly English Lesson Subscription',
        'line_items[0][price_data][unit_amount]': '100', // $1.00
        'line_items[0][quantity]': '1',
        'mode': 'payment',
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏—Ö–∏–µ URL, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç –∫–æ–º–∞–Ω–¥—É start
        'success_url': `https://t.me/${env.BOT_USERNAME}`,
        'cancel_url': `https://t.me/${env.BOT_USERNAME}`,
        'metadata[telegram_id]': telegramId.toString(),
      })
    });
    
    if (!stripeResponse.ok) {
      const errorText = await stripeResponse.text();
      console.error('Stripe API error:', errorText);
      throw new Error(`Stripe API error: ${errorText}`);
    }
    
    const session = await stripeResponse.json();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º session_id –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    await env.USER_DB
      .prepare('UPDATE user_profiles SET stripe_session_id = ? WHERE telegram_id = ?')
      .bind(session.id, parseInt(telegramId, 10))
      .run();
    
    // –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ—Å—Å–∏–∏
    console.log(`Created Stripe session ${session.id} for user ${telegramId}`);
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º URL –¥–ª—è –æ–ø–ª–∞—Ç—ã
    return new Response(JSON.stringify({
      success: true,
      payment_url: session.url,
      session_id: session.id
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    try {
      await env.USER_DB
        .prepare('UPDATE user_profiles SET payment_processing = 0 WHERE telegram_id = ?')
        .bind(parseInt(telegramId, 10))
        .run();
    } catch (resetError) {
      console.error('Error resetting payment_processing flag:', resetError);
    }
    
    console.error('Error creating payment session:', error);
    return new Response(JSON.stringify({
      success: false,
      error: "Payment initialization failed: " + error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç—ã
async function processSubscription(telegramId, env, sessionId = null) {
  try {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { results } = await env.USER_DB
      .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
      .bind(parseInt(telegramId, 10))
      .all();
    
    if (!results.length) {
      return new Response('User not found', { status: 404 });
    }
    
    const profile = results[0];
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª–∞ –ª–∏ —ç—Ç–∞ —Å–µ—Å—Å–∏—è —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞
    if (sessionId) {
      const { results: paymentResults } = await env.USER_DB
        .prepare('SELECT * FROM payment_history WHERE stripe_session_id = ?')
        .bind(sessionId)
        .all();
      
      if (paymentResults.length > 0) {
        console.log(`Payment for session ${sessionId} already processed, skipping`);
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        await env.USER_DB
          .prepare('UPDATE user_profiles SET payment_processing = 0 WHERE telegram_id = ?')
          .bind(parseInt(telegramId, 10))
          .run();
        
        return new Response(JSON.stringify({
          success: true,
          message: "Payment already processed",
          already_processed: true
        }), {
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–∞—Ç—ã –ø–æ–¥–ø–∏—Å–∫–∏
    const now = new Date();
    const subscribed_at = now.toISOString();
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞—Ç—É –∏—Å—Ç–µ—á–µ–Ω–∏—è –Ω–∞ 7 –¥–Ω–µ–π —Å —Ç–µ–∫—É—â–µ–≥–æ –º–æ–º–µ–Ω—Ç–∞
    const expirationDate = new Date(now);
    expirationDate.setDate(expirationDate.getDate() + 7);
    expirationDate.setHours(23, 59, 59, 999);
    const subscription_expired_at = expirationDate.toISOString();
    
    // –î–ª—è –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –¥–µ–ª–∞–µ–º —É—Ä–æ–∫ —Å—Ä–∞–∑—É –¥–æ—Å—Ç—É–ø–Ω—ã–º
    const nextLessonDate = new Date(now);
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if (!profile.subscription_expired_at || new Date(profile.subscription_expired_at) < now) {
      // –ü–µ—Ä–≤—ã–π —Ä–∞–∑ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞ - —Å–¥–µ–ª–∞—Ç—å —É—Ä–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã–º —Å—Ä–∞–∑—É
      nextLessonDate.setTime(now.getTime() - 60000); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞ 1 –º–∏–Ω—É—Ç—É –Ω–∞–∑–∞–¥ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
    } else {
      // –ü—Ä–æ–¥–ª–µ–Ω–∏–µ - —Å–ª–µ–¥—É–µ–º –æ–±—ã—á–Ω–æ–º—É —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
      nextLessonDate.setHours(2, 0, 0, 0);
      // –ï—Å–ª–∏ —É–∂–µ –ø–æ—Å–ª–µ 2 —É—Ç—Ä–∞, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞ –∑–∞–≤—Ç—Ä–∞
      if (now.getHours() >= 2) {
        nextLessonDate.setDate(nextLessonDate.getDate() + 1);
      }
    }
    
    const next_lesson_access_at = nextLessonDate.toISOString();
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Å—É–º–º—É –æ–ø–ª–∞—Ç—ã (–¥–æ–±–∞–≤–ª—è–µ–º $1 –∫ —Ç–µ–∫—É—â–µ–º—É –∑–Ω–∞—á–µ–Ω–∏—é)
    const currentAmount = profile.amount_paid || 0;
    const amount_paid = currentAmount + 1;
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø–ª–∞—Ç–µ–∂ –≤ —Ç–∞–±–ª–∏—Ü—É payment_history –µ—Å–ª–∏ –Ω–µ –∑–∞–ø–∏—Å–∞–Ω —Ä–∞–Ω–µ–µ
    if (sessionId) {
      try {
        await env.USER_DB
          .prepare(`
            INSERT INTO payment_history (
              telegram_id, 
              amount, 
              status, 
              stripe_session_id,
              created_at
            ) VALUES (?, ?, ?, ?, ?)
          `)
          .bind(
            parseInt(telegramId, 10),
            1.00, // $1.00
            'completed',
            sessionId,
            new Date().toISOString()
          )
          .run();
        
        console.log(`Payment recorded for user ${telegramId}, session ${sessionId}`);
      } catch (paymentError) {
        console.error('Error recording payment:', paymentError);
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ –∑–∞–ø–∏—Å–∏ –ø–ª–∞—Ç–µ–∂–∞
      }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    await env.USER_DB
      .prepare(`
        UPDATE user_profiles 
        SET subscribed_at = ?, 
            subscription_expired_at = ?, 
            next_lesson_access_at = ?, 
            amount_paid = ?,
            payment_processing = 0,
            stripe_session_id = NULL
        WHERE telegram_id = ?
      `)
      .bind(
        subscribed_at,
        subscription_expired_at,
        next_lesson_access_at,
        amount_paid,
        parseInt(telegramId, 10)
      )
      .run();
    
    console.log(`Subscription activated for user ${telegramId} until ${subscription_expired_at}`);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await sendSubscriptionConfirmation(telegramId, env);
    
    return new Response(JSON.stringify({
      success: true,
      message: "Subscription activated successfully",
      subscription_expired_at: subscription_expired_at,
      next_lesson_access_at: next_lesson_access_at
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    try {
      await env.USER_DB
        .prepare('UPDATE user_profiles SET payment_processing = 0 WHERE telegram_id = ?')
        .bind(parseInt(telegramId, 10))
        .run();
    } catch (resetError) {
      console.error('Error resetting payment_processing flag:', resetError);
    }
    
    console.error('Error processing subscription:', error);
    return new Response(JSON.stringify({
      success: false,
      error: "Database error: " + error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ —á–µ—Ä–µ–∑ Telegram
async function sendSubscriptionConfirmation(chatId, env) {
  const message = "üéâ Your weekly subscription has been activated! You now have access to personalized English lessons for the next 7 days.";
  
  const keyboard = {
    inline_keyboard: [
      [{ text: "Start Lesson Now", callback_data: "lesson:start" }]
    ]
  };
  
  await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text: message,
      reply_markup: keyboard
    })
  });
}
