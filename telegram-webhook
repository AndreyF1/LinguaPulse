// telegram-webhook/worker.js
// Receives every Telegram update on /tg and routes it to TEST or LESSON0

export default {
  async fetch(request, env) {
    const { pathname } = new URL(request.url);
    if (pathname !== '/tg') return new Response('Not found', { status: 404 });

    // 0. parse safely
    let update = {};
    try { update = await request.json(); } catch { /* ignore parse errors */ }

    const chatId = update.message?.chat?.id
                || update.callback_query?.message?.chat?.id;
    if (!chatId) return new Response('OK');

    // Handle /help command directly in webhook
    if (update.message?.text === '/help') {
      await sendMessageViaTelegram(chatId, 
        'Available commands:\n' +
        '/start - Begin the language placement test or see your profile\n' +
        '/profile - View your language level and progress\n' +
        '/lesson - Access your lessons and subscription status\n' +
        '/help - Show this help message\n\n' +
        'After completing the test, you can:\n' +
        '• Start a free audio lesson by clicking the "Free audio lesson" button\n' +
        '• Send voice messages during the lesson to practice your speaking\n' +
        '• The lesson ends automatically when completed', env);
      return new Response('OK');
    }

    // Handle /profile command - show user-friendly profile data
    if (update.message?.text === '/profile') {
      const { results } = await env.USER_DB
        .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
        .bind(parseInt(chatId, 10))
        .all();
      
      const profile = results[0] || {};
      
      if (!profile.eng_level) {
        await sendMessageViaTelegram(chatId, 
          'You haven\'t taken the placement test yet. Use /start to begin.', env);
      } else {
        // Format human-readable profile info
        const testedAt = profile.tested_at ? new Date(profile.tested_at).toLocaleDateString() : 'N/A';
        const subscriptionEnd = profile.subscription_expired_at ? new Date(profile.subscription_expired_at).toLocaleDateString() : 'No active subscription';
        const lessonsTotal = profile.lessons_total || 0;
        const lessonsStreak = profile.lessons_streak || 0;
        
        await sendMessageViaTelegram(chatId, 
          `Your language profile:\n\n` +
          `Language level: ${profile.eng_level}\n` +
          `Subscription valid until: ${subscriptionEnd}\n` +
          `Total lessons completed: ${lessonsTotal}\n` +
          `Current lesson streak: ${lessonsStreak}`, env);
      }
      
      return new Response('OK');
    }

    // Handle /lesson command - same as /start for users who completed the test
    if (update.message?.text === '/lesson' || 
       (update.message?.text === '/start' && await hasCompletedTest(chatId, env))) {
      await handleLessonCommand(chatId, env);
      return new Response('OK');
    }
      
    // Modified /start command to check for existing level
    if (update.message?.text === '/start') {
      // This will only run if the user has not completed the test
      // (because the previous condition would have caught it otherwise)
      
      // Continue with original /start flow to generate questions
      const questions = await generateTest(env);
      const answers = [];
      const index = 0;
      
      const stateKey = STATE_PREFIX + chatId;
      await env.TEST_KV.put(stateKey, JSON.stringify({ questions, answers, index }));
      
      const startAt = new Date().toISOString();
      await env.USER_DB
        .prepare(
          `INSERT INTO user_profiles (telegram_id, start_test_at)
           VALUES (?, ?)
           ON CONFLICT(telegram_id) DO UPDATE
             SET start_test_at = excluded.start_test_at`
        )
        .bind(parseInt(chatId, 10), startAt)
        .run();
      
      // Ask first question
      const kb = questions[0].options.map(o => [{
        text: o,
        callback_data: `next:${o}`
      }]);
      
      await sendMessageViaTelegram(chatId, questions[0].question, env, { inline_keyboard: kb });
      return new Response('OK');
    }

    // 1. read current lesson flag
    const flagKey   = `lesson:${chatId}`;
    const lessonFlg = (await env.USER_PROFILE.get(flagKey)) || 'idle';

    // 2. handle lesson buttons
    if (update.callback_query?.data === 'lesson:free' || 
        update.callback_query?.data === 'lesson:start') {
      // send the "Starting…" text back immediately
      await sendMessageViaTelegram(chatId,
        'Starting audio lesson…', env);

      // mark lesson in progress
      await env.USER_PROFILE.put(flagKey, 'in_progress');

      // forward the start payload to lesson0-bot
      return forward(env.LESSON0, {
        user_id: chatId,
        action : update.callback_query?.data === 'lesson:free' ? 'start_free' : 'start_lesson'
      });
    }
    
    // 2.1 handle subscription button
    if (update.callback_query?.data === 'sub:weekly') {
      // Acknowledge the callback query to remove the loading indicator
      await callTelegram('answerCallbackQuery', {
        callback_query_id: update.callback_query.id
      }, env);
      
      // Check current subscription status
      const { results } = await env.USER_DB
        .prepare('SELECT subscription_expired_at, next_lesson_access_at FROM user_profiles WHERE telegram_id = ?')
        .bind(parseInt(chatId, 10))
        .all();
      
      if (!results.length) {
        await sendMessageViaTelegram(chatId, 
          'You need to take the placement test first. Use /start to begin.', env);
        return new Response('OK');
      }
      
      const profile = results[0];
      const now = new Date();
      
      // Check if user has an active subscription
      if (profile.subscription_expired_at) {
        const subExpiredAt = new Date(profile.subscription_expired_at);
        
        // If subscription is still active
        if (subExpiredAt.getTime() > now.getTime()) {
          // Format the expiration date
          const expiryDate = subExpiredAt.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Check if next lesson is available
          if (profile.next_lesson_access_at) {
            const nextLessonAt = new Date(profile.next_lesson_access_at);
            
            if (nextLessonAt.getTime() <= now.getTime()) {
              // Next lesson is already available
              await sendMessageViaTelegram(chatId,
                `You already have an active subscription until ${expiryDate}. Your next lesson is available now!`, 
                env, 
                { inline_keyboard: [[{ text: "Start Lesson", callback_data: "lesson:start" }]] }
              );
            } else {
              // Next lesson will be available later
              const timeUntil = formatTimeUntil(nextLessonAt);
              await sendMessageViaTelegram(chatId,
                `You already have an active subscription until ${expiryDate}. Your next lesson will be available in ${timeUntil}.`,
                env
              );
            }
            return new Response('OK');
          } else {
            // Something went wrong - subscription exists but next_lesson_access_at is missing
            await sendMessageViaTelegram(chatId,
              `You already have an active subscription until ${expiryDate}.`,
              env,
              { inline_keyboard: [[{ text: "Start Lesson", callback_data: "lesson:start" }]] }
            );
            return new Response('OK');
          }
        }
      }
      
      // If we get here, user doesn't have an active subscription or it has expired
      // Process the new subscription
      try {
        // Call the payment worker directly using the service binding
        const paymentResponse = await env.PAYMENT.fetch('https://internal/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            telegram_id: chatId,
            action: 'process_subscription'
          })
        });
        
        if (!paymentResponse.ok) {
          throw new Error(`Payment processing failed: ${paymentResponse.status}`);
        }
        
        // The payment worker will handle sending the confirmation message
        // and updating the user's subscription status
        
      } catch (error) {
        console.error('Payment error:', error);
        
        // Send error message to user
        await sendMessageViaTelegram(chatId,
          'Sorry, there was an error processing your subscription. Please try again later.', env);
      }
      
      return new Response('OK');
    }

    // 3. proxy user voice while lesson is in progress
    if (lessonFlg === 'in_progress' && update.message?.voice) {
      return forward(env.LESSON0, update);
    }

    // 4. receive end-of-lesson notification (if you choose to send it)
    if (update.lesson_done) {
      await env.USER_PROFILE.put(flagKey, 'finished', { expirationTtl: 86400 });
      return new Response('OK');
    }

    // 5. everything else goes to test-bot
    return forward(env.TEST, update);
  }
};

// KV prefix for transient test state
const STATE_PREFIX = 'state:';

/* ──── helper: send a text via Telegram Bot API ──── */
async function sendMessageViaTelegram(chatId, text, env, keyboard = null) {
  const payload = { chat_id: chatId, text };
  
  if (keyboard) {
    payload.reply_markup = keyboard;
  }
  
  return callTelegram('sendMessage', payload, env);
}

/* ──── helper: call any Telegram API method ──── */
async function callTelegram(method, payload, env) {
  return fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/${method}`, {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify(payload)
  });
}

/* ──── helper: proxy payload to another Worker ──── */
function forward(service, payload) {
  return service.fetch('https://internal/', {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify(payload)
  });
}

/* ──── helper: check if user has completed test ──── */
async function hasCompletedTest(chatId, env) {
  const { results } = await env.USER_DB
    .prepare('SELECT eng_level FROM user_profiles WHERE telegram_id = ?')
    .bind(parseInt(chatId, 10))
    .all();
  
  return results[0]?.eng_level ? true : false;
}

/* ──── helper: handle lesson command ──── */
async function handleLessonCommand(chatId, env) {
  // Get user profile with all necessary fields
  const { results } = await env.USER_DB
    .prepare('SELECT * FROM user_profiles WHERE telegram_id = ?')
    .bind(parseInt(chatId, 10))
    .all();
  
  if (!results.length) {
    await sendMessageViaTelegram(chatId, 
      'You need to take the placement test first. Use /start to begin.', env);
    return;
  }
  
  const profile = results[0];
  
  // Basic profile info
  const testedAt = profile.tested_at ? new Date(profile.tested_at).toLocaleDateString() : 'N/A';
  const lessonsTotal = profile.lessons_total || 0;
  const lessonsStreak = profile.lessons_streak || 0;
  
  let message = `Your language profile:\n` +
    `Language level: ${profile.eng_level}\n` +
    `Total lessons completed: ${lessonsTotal}\n` +
    `Current lesson streak: ${lessonsStreak}\n\n`;
  
  // Check pass_lesson0_at first
  if (!profile.pass_lesson0_at) {
    // Free lesson not taken yet - show button
    message += 'You haven\'t taken your free introductory lesson yet.';
    await sendMessageViaTelegram(chatId, message, env, {
      inline_keyboard: [[{ text: 'Free audio lesson', callback_data: 'lesson:free' }]]
    });
    return;
  }
  
  // Check subscription status
  const now = new Date();
  const subExpiredAt = profile.subscription_expired_at ? new Date(profile.subscription_expired_at) : null;
  
  if (!subExpiredAt || subExpiredAt.getTime() < now.getTime()) {
    // No active subscription or it's expired - show subscribe button
    message += 'Your subscription has expired or you haven\'t subscribed yet.';
    await sendMessageViaTelegram(chatId, message, env, {
      inline_keyboard: [[{ text: 'Subscribe for $1/week', callback_data: 'sub:weekly' }]]
    });
    return;
  }
  
  // Active subscription - show next lesson access time
  const nextLessonAt = profile.next_lesson_access_at ? new Date(profile.next_lesson_access_at) : null;
  
  if (nextLessonAt && nextLessonAt.getTime() > now.getTime()) {
    // Format the time until next lesson
    const timeUntil = formatTimeUntil(nextLessonAt);
    message += `Your next lesson will be available in ${timeUntil}.`;
    await sendMessageViaTelegram(chatId, message, env);
    return;
  }
  
  // Lesson is available now
  message += 'Your next lesson is available now!';
  await sendMessageViaTelegram(chatId, message, env, {
    inline_keyboard: [[{ text: 'Start lesson', callback_data: 'lesson:start' }]]
  });
}

/* ──── helper: format time until date in human-readable form ──── */
function formatTimeUntil(date) {
  const now = new Date();
  const diffMs = date.getTime() - now.getTime();
  
  if (diffMs <= 0) return 'now';
  
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHr = Math.floor(diffMin / 60);
  const diffDays = Math.floor(diffHr / 24);
  
  if (diffDays > 0) {
    return `${diffDays} day${diffDays > 1 ? 's' : ''}`;
  } else if (diffHr > 0) {
    return `${diffHr} hour${diffHr > 1 ? 's' : ''}`;
  } else if (diffMin > 0) {
    return `${diffMin} minute${diffMin > 1 ? 's' : ''}`;
  } else {
    return `${diffSec} second${diffSec > 1 ? 's' : ''}`;
  }
}

// GPT-based question generation
async function generateTest(env) {
  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${env.OPENAI_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-3.5-turbo',
      temperature: 0.7,
      max_tokens: 800,
      messages: [
        { role: 'system', content: env.SYSTEM_PROMPT },
        { role: 'user',   content: env.USER_PROMPT }
      ]
    })
  });

  const data = await res.json();
  let txt = data.choices?.[0]?.message?.content?.trim() || '';
  txt = txt.replace(/^```(?:json)?/, '').replace(/```$/, '').trim();

  let parsed;
  try {
    parsed = JSON.parse(txt);
  } catch (e) {
    console.error('generateTest parse error:', txt, e);
    throw new Error('Failed to parse questions JSON');
  }

  const arr = Array.isArray(parsed)
    ? parsed
    : Array.isArray(parsed.questions) ? parsed.questions : [];
  return arr.slice(0, 10).map(q => ({
    question: q.question,
    options: Array.isArray(q.options) ? q.options.slice(0, 4) : [],
    answer: q.answer
  }));
}
