// telegram-webhook/worker.js
// Receives every Telegram update on /tg and routes it to TEST or LESSON0

export default {
  async fetch(request, env) {
    const { pathname } = new URL(request.url);
    if (pathname !== '/tg') return new Response('Not found', { status: 404 });

    // 0. parse safely
    let update = {};
    try { update = await request.json(); } catch { /* ignore parse errors */ }

    const chatId = update.message?.chat?.id
                || update.callback_query?.message?.chat?.id;
    if (!chatId) return new Response('OK');

    // Handle callback_query events
    if (update.callback_query) {
      // Handle "Free audio lesson" button
      if (update.callback_query.data === 'lesson:free') {
        // Check if user has already completed the free lesson before
        const { results } = await env.USER_DB
          .prepare('SELECT pass_lesson0_at FROM user_profiles WHERE telegram_id = ?')
          .bind(parseInt(chatId, 10))
          .all();
          
        if (results.length > 0 && results[0].pass_lesson0_at) {
          // If user already completed the free lesson, show subscription message
          await sendMessageViaTelegram(chatId,
            "You've already completed your free trial lesson. If you'd like to continue practicing English, you can subscribe for just $1 per week. This gives you access to one extended lesson every day with personalized feedback.",
            env,
            [[{ text: "Subscribe for $1/week", callback_data: "subscribe:weekly" }]]
          );
          return new Response('OK');
        }
        
        // If not completed before, send the "Startingâ€¦" text back immediately
        await sendMessageViaTelegram(chatId,
          'Starting free audio lessonâ€¦', env);

        // Mark lesson in progress
        await env.USER_PROFILE.put(`lesson:${chatId}`, 'in_progress');

        // Forward the start payload to lesson0-bot
        return forward(env.LESSON0, {
          user_id: chatId,
          action : 'start_free'
        });
      }
      
      // Handle subscription button
      if (update.callback_query.data === 'subscribe:weekly') {
        // Acknowledge the callback to stop the loading animation
        await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/answerCallbackQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callback_query_id: update.callback_query.id })
        });
        
        // Here you would implement actual subscription logic
        // For now, just acknowledge the request
        await sendMessageViaTelegram(
          chatId,
          "Thank you for your interest in our premium subscription! We'll be launching this feature soon. You'll be among the first to know when it's available.",
          env
        );
        return new Response('OK');
      }
      
      // Handle test retake button
      if (update.callback_query.data === 'test:retake') {
        // Acknowledge the callback
        await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/answerCallbackQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callback_query_id: update.callback_query.id })
        });
        
        await sendMessageViaTelegram(
          chatId,
          "Let's reassess your English level! I'm going to ask you a series of questions to determine your proficiency.",
          env
        );
        
        // Forward to test-bot with retake flag
        return forward(env.TEST, {
          ...update,
          message: { chat: { id: chatId }, text: '/start' },
          retake_test: true
        });
      }
      
      // Handle keep current level button
      if (update.callback_query.data === 'test:keep') {
        // Acknowledge the callback
        await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/answerCallbackQuery`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callback_query_id: update.callback_query.id })
        });
        
        await sendMessageViaTelegram(
          chatId,
          "Got it! We'll keep your current level. You can always practice with our free audio lesson to improve your skills.",
          env,
          [[{ text: "Free Audio Lesson", callback_data: "lesson:free" }]]
        );
        return new Response('OK');
      }
      
      // Other callback queries go to test-bot
      return forward(env.TEST, update);
    }

    // Handle commands
    if (update.message?.text) {
      // Help command
      if (update.message.text === '/help') {
        await sendMessageViaTelegram(
          chatId,
          "ðŸ¤– *LinguaPulse Bot*\n\nPractice your English through natural conversation!\n\nCommands:\n/start - Run placement test or view your stats\n/help - Show this help message",
          env,
          null,
          'Markdown'
        );
        return new Response('OK');
      }
      
      // Start command - display user stats or initiate test
      if (update.message.text === '/start') {
        // Check if user has already taken the test
        const { results } = await env.USER_DB
          .prepare('SELECT eng_level, tested_at, pass_lesson0_at, COALESCE(number_of_lessons, 0) as number_of_lessons, COALESCE(lessons_in_row, 0) as lessons_in_row, subscription_expired_at FROM user_profiles WHERE telegram_id = ?')
          .bind(parseInt(chatId, 10))
          .all();
          
        if (results.length > 0 && results[0].eng_level) {
          // User already has eng_level, show stats
          const profile = results[0];
          const testedDate = new Date(profile.tested_at).toLocaleDateString();
          const subscriptionStatus = profile.subscription_expired_at 
            ? `Your subscription is active until ${new Date(profile.subscription_expired_at).toLocaleDateString()}`
            : "You don't have an active subscription";
            
          await sendMessageViaTelegram(
            chatId,
            `ðŸ“Š *Your LinguaPulse Profile*\n\n` +
            `ðŸ”¤ English level: *${profile.eng_level}*\n` +
            `ðŸ“ Last tested: *${testedDate}*\n` +
            `ðŸ”¢ Total lessons: *${profile.number_of_lessons}*\n` +
            `ðŸ”¥ Streak: *${profile.lessons_in_row} days*\n\n` +
            `ðŸ’³ ${subscriptionStatus}\n\n` +
            `Want to practice speaking? Try our free conversation lesson!`,
            env,
            [[{ text: "Free Audio Lesson", callback_data: "lesson:free" }]],
            'Markdown'
          );
          return new Response('OK');
        } else {
          // User needs to take the test
          // Check if user has already taken the test but failed to complete it
          if (results.length > 0 && results[0].tested_at) {
            await sendMessageViaTelegram(
              chatId,
              "It looks like you started the test but didn't complete it. Let's try again!",
              env
            );
          } else {
            await sendMessageViaTelegram(
              chatId,
              "Welcome to LinguaPulse! Let's start by determining your English level with a short placement test.",
              env
            );
          }
          
          // Forward to test-bot
          return forward(env.TEST, update);
        }
      }
    }

    // 1. read current lesson flag
    const flagKey   = `lesson:${chatId}`;
    const lessonFlg = (await env.USER_PROFILE.get(flagKey)) || 'idle';

    // 3. proxy user voice while lesson is in progress
    if (lessonFlg === 'in_progress' && update.message?.voice) {
      return forward(env.LESSON0, update);
    }

    // 4. receive end-of-lesson notification (if you choose to send it)
    if (update.lesson_done) {
      await env.USER_PROFILE.put(flagKey, 'finished', { expirationTtl: 86400 });
      return new Response('OK');
    }

    // 5. everything else goes to test-bot
    // But first check if we're starting a new test
    if (update.message?.text === '/test') {
      // Check if user has already taken the test
      const { results } = await env.USER_DB
        .prepare('SELECT eng_level, tested_at FROM user_profiles WHERE telegram_id = ?')
        .bind(parseInt(chatId, 10))
        .all();
        
      if (results.length > 0 && results[0].eng_level) {
        // User already has eng_level, ask if they want to retake
        await sendMessageViaTelegram(
          chatId,
          `You've already taken the placement test and your level is ${results[0].eng_level}. Would you like to take it again to see if you've improved?`,
          env,
          [
            [{ text: "Yes, retake test", callback_data: "test:retake" }],
            [{ text: "No, keep my current level", callback_data: "test:keep" }]
          ]
        );
        return new Response('OK');
      }
    }
    
    return forward(env.TEST, update);
  }
};

/* â”€â”€â”€â”€ helper: send a text via Telegram Bot API â”€â”€â”€â”€ */
async function sendMessageViaTelegram(chatId, text, env, keyboard = null, parseMode = null) {
  const body = { chat_id: chatId, text };
  
  if (keyboard) {
    body.reply_markup = { inline_keyboard: keyboard };
  }
  
  if (parseMode) {
    body.parse_mode = parseMode;
  }
  
  await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/sendMessage`, {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify(body)
  });
}

/* â”€â”€â”€â”€ helper: proxy payload to another Worker â”€â”€â”€â”€ */
function forward(service, payload) {
  return service.fetch('https://internal/', {
    method : 'POST',
    headers: { 'Content-Type': 'application/json' },
    body   : JSON.stringify(payload)
  });
}
